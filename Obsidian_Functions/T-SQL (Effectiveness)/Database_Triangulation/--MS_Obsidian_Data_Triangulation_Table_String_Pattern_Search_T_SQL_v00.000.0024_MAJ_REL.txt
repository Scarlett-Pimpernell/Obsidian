--MS_Obsidian_Database_Triangulation_Table_String_Pattern_Search_T_SQL_v00.000.0024_MAJ_REL
--It allows you to pass in a string pattern, which will then be searched for across all the tables in your database...
--If you want to also use this search against views, then please feel free to make the appropriate amendments...
--The output provides a list of all the table names and column names that contain the search string pattern within their requisite cell data...
--There are global variables available regarding switching between exact match and partial match, but please be aware that exact match is likely to be a much quicker search in almost all circumstances...
--There is likely a query column search count limit, due to the count of union alls in a dynamic t-sql execution, and indeed string sizes in general (I hear that the query source code character limit is about 250K, and that utilised NVarchar(Max) data fields have a character limit each of around 1 billion, but not sure if any of this will have any impact, as I have not tested thoroughly)
--I may include regex capabilities in a distant update to these algorithms...
--Oh and BTW, if you havent realised, you can actually use these algorithms to support a nifty and simplified data discovery user interface via desktop/website/robot etc_...
--Adjust all the data type sizes, and check for unnecessary casting throughout, before final release!!!!!!!
--Should I include found string in the output table???... Most likely yes, so do this soon!


--GLOBAL VARIABLES
--This following variable sets the any value tag for the blacklist and whitelist tables below... Please feel free to change it appropriately, if you have a usecase where one of your database objects is called [All_Combinations]... Otherwise ignoring and including will not work as expected, leading to unstable algorithm behaviour.
Declare @All_Combinations_Tag As NVarchar(4000)
Set @All_Combinations_Tag = 'All_Combinations'

--Use this table variable to set the search protocols for the algorithm to follow... The match type column can be set to either: "Exact" or "Partial" (In either case, without the double quotes)
Declare @Search_Protocols Table ([Search_String] NVarchar(4000), [Match_Type] NVarchar(4000))
Insert Into @Search_Protocols ([Search_String], [Match_Type])
Values
(N'149ED75C889A4356ADF8D6E95A729ACD', N'Exact'),
(N'Category', N'Partial'),
(N'Search_Protocol_Example_0001', N'Exact')

--Use this table variable to set the column data types for the algorithm to ignore... Afterall, one should probably not attempt to search a textual string against data values in and image column (this is not IDs or computer/human language) or even varbinary column (this is almost always not a useful task)... You can add any user-defined data types here also.
Declare @Ignore_Column_Data_Types Table ([Data_Type_Name] NVarchar(4000))
Insert Into @Ignore_Column_Data_Types ([Data_Type_Name])
Values
(N'geography'),
(N'geometry'),
(N'hierarchyid'),
(N'image'),
(N'rowversion'),
(N'varbinary'),
(N'xml'),
(N'bit'),
(N'User_Defined_Type_Example_0001') --An example user-defined data type.

--SOURCECODE_LOGICAL_CHUNK--SOURCECODE_LOGICAL_CHUNK--SOURCECODE_LOGICAL_CHUNK--SOURCECODE_LOGICAL_CHUNK--SOURCECODE_LOGICAL_CHUNK
--(BLACKLIST --> Subordinates To --> WHITELIST {In the codeblock below})
--Use this table variable to set the table and column names for the algorithm to ignore (and please bear in mind whitelist/blacklist precedence)... Afterall, one should probably not attempt to search through absolutely massive tables or columns in a lax way, or without great cause... You can even choose to manually ignore tables or columns that you think are causing the algorithm to crash or slow to a grind, for example because of strange data types or massive amount of rows and/or columns contained within.
--By the way, this algorithm is smart enough to handle partial blacklist column data, for example where you don't want to specify every table or column that you want to ignore.
--WITHIN THIS BLACKLIST IGNORES TABLE VARIABLE, PLEASE MAKE SURE YOU DON'T USE SQUARE BRACKET NOTATION FOR THE SPECIFIC DATABASE OBJECTS REFERENCED USING STRINGS... SQUARE BRACKETS WILL AUTOMATICALLY BE ADDED LATER ON IN THE ALGORITHM!!!
Declare @Blacklist_Ignores Table ([Table_Catalog] NVarchar(4000), [Table_Schema] NVarchar(4000), [Table_Name] NVarchar(4000), [Column_Name] NVarchar(4000))
Insert Into @Blacklist_Ignores ([Table_Catalog], [Table_Schema], [Table_Name], [Column_Name])
Values
(N'Obsidian_SQL_Server_2022', @All_Combinations_Tag, @All_Combinations_Tag, @All_Combinations_Tag),
(N'MSOAEGS_0011_PT_1K', @All_Combinations_Tag, N'MooDPrimaryElement', @All_Combinations_Tag),
(N'MSOAEGS_0011_PT_1K', @All_Combinations_Tag, N'MooDUsedByElementMap', @All_Combinations_Tag)
--(Add ignore protocols here, as extra insert values rows... Please don't forget comma separation within and across rows! {You will need to always have at least 3 commas within row, as there are 4 columns in the blacklist insert into command... Also, you will need to provide a special keyword variable [@All_Combinations_Tag], obviously without the square brackets, wherever you are not specifying data in a blacklist protocol column [Please see the original example insert values for an idea of how to do this here]... This will emulate an any value functionality in the respective column.})

--[If there are rows inserted into the whitelist below this sourcecode line, then the blacklist above this sourcecode line will be ignored, for obvious reasons.]
--[If there are rows inserted into the whitelist below this sourcecode line, then the blacklist above this sourcecode line will be ignored, for obvious reasons.]
--[If there are rows inserted into the whitelist below this sourcecode line, then the blacklist above this sourcecode line will be ignored, for obvious reasons.]
--[If there are rows inserted into the whitelist below this sourcecode line, then the blacklist above this sourcecode line will be ignored, for obvious reasons.]
--[If there are rows inserted into the whitelist below this sourcecode line, then the blacklist above this sourcecode line will be ignored, for obvious reasons.]

--(WHITELIST --> Superceeds From --> BLACKLIST {In the codeblock above})
--Use this table variable to set the table names for the algorithm to include (and please bear in mind whitelist/blacklist precedence)... Afterall, one should probably not attempt to search through absolutely massive tables or columns in a lax way, or without great cause... You can even choose to manually include tables or columns that you think are essential for the successful execution of the algorithm, to the exclusion of all else as unnecessary string pattern search space.
--By the way, this algorithm is smart enough to handle partial whitelist column data, for example where you don't want to specify every catalog or schema that you want to include.
--WITHIN THIS WHITELIST INCLUSIONS TABLE VARIABLE, PLEASE MAKE SURE YOU DON'T USE SQUARE BRACKET NOTATION FOR THE SPECIFIC DATABASE OBJECTS REFERENCED USING STRINGS... SQUARE BRACKETS WILL AUTOMATICALLY BE ADDED LATER ON IN THE ALGORITHM!!!
Declare @Whitelist_Inlcusions Table ([Table_Catalog] NVarchar(4000), [Table_Schema] NVarchar(4000), [Table_Name] NVarchar(4000), [Column_Name] NVarchar(4000))
Insert Into @Whitelist_Inlcusions ([Table_Catalog], [Table_Schema], [Table_Name], [Column_Name])
Values
(N'MSOAEGS_0011_PT_1K', @All_Combinations_Tag, N'MooDPrimaryElement', @All_Combinations_Tag),
(N'MSOAEGS_0011_PT_1K', N'dbo', N'MooDUsedByElementMap', @All_Combinations_Tag),
(N'MS_Obsidian_Auto_Archive_Generator_Baseline', @All_Combinations_Tag, @All_Combinations_Tag, @All_Combinations_Tag)
--(Add include protocols here, as extra insert values rows... Please don't forget comma separation within and across rows! {You will need to always have at least 3 commas within row, as there are 4 columns in the whitelist insert into command}... Also, you will need to provide a special keyword variable [@All_Combinations_Tag], obviously without the square brackets, wherever you are not specifying data in a whitelist protocol column [Please see the original example insert values for an idea of how to do this here]... This will emulate an any value functionality in the respective column.})
--SOURCECODE_LOGICAL_CHUNK--SOURCECODE_LOGICAL_CHUNK--SOURCECODE_LOGICAL_CHUNK--SOURCECODE_LOGICAL_CHUNK--SOURCECODE_LOGICAL_CHUNK


--DATA VALIDATION
--Will need to check that no catalog, schema, table, or column is called 'All_Combinations' --> Eventually provide user with the ability to set their own anything global variables tag, incase they do have objects called 'All_Combinations' that they want to keep using.

--ALGORITHM EXECUTION
Declare @Search_Protocols_Consolidated Table ([Search_String] NVarchar(4000), [Match_Type] NVarchar(4000))
Insert Into @Search_Protocols_Consolidated ([Search_String], [Match_Type])
Select
	[Search_String] As [Search_String],
	Min([Match_Type]) As [Match_Type] --This should prudently alphabetically choose "Exact" over "Partial" wherever there is a duplication of the same string pattern with different match types... Although I haven't tested yet! 
From @Search_Protocols Group By [Search_String]

Declare @Blacklist_Ignores_Consolidated Table ([Table_Catalog] NVarchar(4000), [Table_Schema] NVarchar(4000), [Table_Name] NVarchar(4000), [Column_Name] NVarchar(4000))
Insert Into @Blacklist_Ignores_Consolidated ([Table_Catalog], [Table_Schema], [Table_Name], [Column_Name])
Select * From @Blacklist_Ignores
Where
	[Table_Catalog] != @All_Combinations_Tag
	Or [Table_Schema] != @All_Combinations_Tag
	Or [Table_Name] != @All_Combinations_Tag
	Or [Column_Name] != @All_Combinations_Tag

Declare @Whitelist_Inlcusions_Consolidated Table ([Table_Catalog] NVarchar(4000), [Table_Schema] NVarchar(4000), [Table_Name] NVarchar(4000), [Column_Name] NVarchar(4000))
Insert Into @Whitelist_Inlcusions_Consolidated ([Table_Catalog], [Table_Schema], [Table_Name], [Column_Name])
Select * From @Whitelist_Inlcusions
Where
	[Table_Catalog] != @All_Combinations_Tag
	Or [Table_Schema] != @All_Combinations_Tag
	Or [Table_Name] != @All_Combinations_Tag
	Or [Column_Name] != @All_Combinations_Tag

--SOURCECODE_LOGICAL_CHUNK--SOURCECODE_LOGICAL_CHUNK--SOURCECODE_LOGICAL_CHUNK--SOURCECODE_LOGICAL_CHUNK--SOURCECODE_LOGICAL_CHUNK
Declare @Triangulation_Dynamic_Search Table ([Substatementlet_Strings] NVarchar(Max))

--Check empty, one row, and many rows works for the logic here, before releasing the algorithm...
If (select 1 where Exists (select 1 from @Whitelist_Inlcusions)) = 1
	
	Begin
	
	Insert Into @Triangulation_Dynamic_Search ([Substatementlet_Strings])
	Select
		((N'Select Max(''' + Cast(A.[Table_Catalog] As NVarchar(Max)) + N''') As [Table_Catalog], Max(''' + Cast(A.[Table_Schema] As NVarchar(Max)) + N''') As [Table_Schema], Max(''' + Cast(A.[Table_Name] As NVarchar(Max)) + N''') As [Table_Name], Max(''' + Cast(A.[Column_Name] As NVarchar(Max)) + N''') As [Column_Name], Max(''' + Cast(D.[Search_String] As NVarchar(Max)) + N''') As [Search_String], Max(''' + Cast(D.[Match_Type] As NVarchar(Max)) + N''') As [Match_Type] From [' + (Cast(A.[Table_Catalog] As NVarchar(Max)) + N'].[' + Cast(A.[Table_Schema] As NVarchar(Max)) + N'].[' + Cast(A.[Table_Name] As NVarchar(Max)))) + (N'] Where [' + Cast(A.[Column_Name] As NVarchar(Max)) + (Case When D.[Match_Type] = 'Exact' Then (N'] Like ''' + Cast(D.[Search_String] As NVarchar(4000)) + N'''') Else (Case When D.[Match_Type] = 'Partial' Then (N'] Like ''%' + Cast(D.[Search_String] As NVarchar(4000)) + N'%''') Else 'Pray_Beg_Forgiveness_For_This_Error' End) End)) + ' Group By [' + Cast(A.[Column_Name] As NVarchar(Max)) + ']') As [Dynamic_Join_String]
	From Information_Schema.Columns A
	Left Join @Ignore_Column_Data_Types B On 
		(A.[Data_Type] = B.[Data_Type_Name])
	Left Join @Whitelist_Inlcusions_Consolidated C On
		(
		--All Protocol Values Specified
		A.[Table_Catalog] = C.[Table_Catalog] And A.[Table_Schema] = C.[Table_Schema] And A.[Table_Name] = C.[Table_Name] And A.[Column_Name] = C.[Column_Name]
		--One Protocol Value Wildcarded
		Or
		C.[Table_Catalog] = @All_Combinations_Tag And A.[Table_Schema] = C.[Table_Schema] And A.[Table_Name] = C.[Table_Name] And A.[Column_Name] = C.[Column_Name]
		Or
		A.[Table_Catalog] = C.[Table_Catalog] And C.[Table_Schema] = @All_Combinations_Tag And A.[Table_Name] = C.[Table_Name] And A.[Column_Name] = C.[Column_Name]
		Or
		A.[Table_Catalog] = C.[Table_Catalog] And A.[Table_Schema] = C.[Table_Schema] And C.[Table_Name] = @All_Combinations_Tag And A.[Column_Name] = C.[Column_Name]
		Or
		A.[Table_Catalog] = C.[Table_Catalog] And A.[Table_Schema] = C.[Table_Schema] And A.[Table_Name] = C.[Table_Name] And C.[Column_Name] = @All_Combinations_Tag
		--Two Protocol Values Wildcarded
		Or
		C.[Table_Catalog] = @All_Combinations_Tag And C.[Table_Schema] = @All_Combinations_Tag And A.[Table_Name] = C.[Table_Name] And A.[Column_Name] = C.[Column_Name]
		Or
		A.[Table_Catalog] = C.[Table_Catalog] And C.[Table_Schema] = @All_Combinations_Tag And C.[Table_Name] = @All_Combinations_Tag And A.[Column_Name] = C.[Column_Name]
		Or
		A.[Table_Catalog] = C.[Table_Catalog] And A.[Table_Schema] = C.[Table_Schema] And C.[Table_Name] = @All_Combinations_Tag And C.[Column_Name] = @All_Combinations_Tag
		Or
		C.[Table_Catalog] = @All_Combinations_Tag And A.[Table_Schema] = C.[Table_Schema] And A.[Table_Name] = C.[Table_Name] And C.[Column_Name] = @All_Combinations_Tag
		Or
		C.[Table_Catalog] = @All_Combinations_Tag And A.[Table_Schema] = C.[Table_Schema] And C.[Table_Name] = @All_Combinations_Tag And A.[Column_Name] = C.[Column_Name]
		Or
		A.[Table_Catalog] = C.[Table_Catalog] And C.[Table_Schema] = @All_Combinations_Tag And A.[Table_Name] = C.[Table_Name] And C.[Column_Name] = @All_Combinations_Tag
		--Three Protocol Values Wildcarded
		Or
		C.[Table_Catalog] = @All_Combinations_Tag And C.[Table_Schema] = @All_Combinations_Tag And C.[Table_Name] = @All_Combinations_Tag And A.[Column_Name] = C.[Column_Name]
		Or
		A.[Table_Catalog] = C.[Table_Catalog] And C.[Table_Schema] = @All_Combinations_Tag And C.[Table_Name] = @All_Combinations_Tag And C.[Column_Name] = @All_Combinations_Tag
		Or
		C.[Table_Catalog] = @All_Combinations_Tag And C.[Table_Schema] = @All_Combinations_Tag And A.[Table_Name] = C.[Table_Name] And C.[Column_Name] = @All_Combinations_Tag
		Or
		C.[Table_Catalog] = @All_Combinations_Tag And A.[Table_Schema] = C.[Table_Schema] And C.[Table_Name] = @All_Combinations_Tag And C.[Column_Name] = @All_Combinations_Tag
		)
	Cross Join @Search_Protocols D
	Where
		B.[Data_Type_Name] Is Null
		And C.[Table_Catalog] Is Not Null
		--We only need to efficiently check the one column for nullity, because we handle the join cleverly above!!!
	Group By A.[Table_Catalog], A.[Table_Schema], A.[Table_Name], A.[Column_Name], D.[Search_String], D.[Match_Type]

	End

Else

	Begin

	--Check empty, one row, and many rows works for the logic here, before releasing the algorithm...
	If (select 1 where Exists (select 1 from @Blacklist_Ignores)) = 1
	
		Begin

		Insert Into @Triangulation_Dynamic_Search ([Substatementlet_Strings])
		Select
			((N'Select Max(''' + Cast(A.[Table_Catalog] As NVarchar(Max)) + N''') As [Table_Catalog], Max(''' + Cast(A.[Table_Schema] As NVarchar(Max)) + N''') As [Table_Schema], Max(''' + Cast(A.[Table_Name] As NVarchar(Max)) + N''') As [Table_Name], Max(''' + Cast(A.[Column_Name] As NVarchar(Max)) + N''') As [Column_Name], Max(''' + Cast(D.[Search_String] As NVarchar(Max)) + N''') As [Search_String], Max(''' + Cast(D.[Match_Type] As NVarchar(Max)) + N''') As [Match_Type] From [' + (Cast(A.[Table_Catalog] As NVarchar(Max)) + N'].[' + Cast(A.[Table_Schema] As NVarchar(Max)) + N'].[' + Cast(A.[Table_Name] As NVarchar(Max)))) + (N'] Where [' + Cast(A.[Column_Name] As NVarchar(Max)) + (Case When D.[Match_Type] = 'Exact' Then (N'] Like ''' + Cast(D.[Search_String] As NVarchar(4000)) + N'''') Else (Case When D.[Match_Type] = 'Partial' Then (N'] Like ''%' + Cast(D.[Search_String] As NVarchar(4000)) + N'%''') Else 'Pray_Beg_Forgiveness_For_This_Error' End) End)) + ' Group By [' + Cast(A.[Column_Name] As NVarchar(Max)) + ']') As [Dynamic_Join_String]
		From Information_Schema.Columns A
		Left Join @Ignore_Column_Data_Types B On 
			(A.[Data_Type] = B.[Data_Type_Name])
		Left Join @Blacklist_Ignores_Consolidated C On
			(
			--All Protocol Values Specified
			A.[Table_Catalog] = C.[Table_Catalog] And A.[Table_Schema] = C.[Table_Schema] And A.[Table_Name] = C.[Table_Name] And A.[Column_Name] = C.[Column_Name]
			--One Protocol Value Wildcarded
			Or
			C.[Table_Catalog] = @All_Combinations_Tag And A.[Table_Schema] = C.[Table_Schema] And A.[Table_Name] = C.[Table_Name] And A.[Column_Name] = C.[Column_Name]
			Or
			A.[Table_Catalog] = C.[Table_Catalog] And C.[Table_Schema] = @All_Combinations_Tag And A.[Table_Name] = C.[Table_Name] And A.[Column_Name] = C.[Column_Name]
			Or
			A.[Table_Catalog] = C.[Table_Catalog] And A.[Table_Schema] = C.[Table_Schema] And C.[Table_Name] = @All_Combinations_Tag And A.[Column_Name] = C.[Column_Name]
			Or
			A.[Table_Catalog] = C.[Table_Catalog] And A.[Table_Schema] = C.[Table_Schema] And A.[Table_Name] = C.[Table_Name] And C.[Column_Name] = @All_Combinations_Tag
			--Two Protocol Values Wildcarded
			Or
			C.[Table_Catalog] = @All_Combinations_Tag And C.[Table_Schema] = @All_Combinations_Tag And A.[Table_Name] = C.[Table_Name] And A.[Column_Name] = C.[Column_Name]
			Or
			A.[Table_Catalog] = C.[Table_Catalog] And C.[Table_Schema] = @All_Combinations_Tag And C.[Table_Name] = @All_Combinations_Tag And A.[Column_Name] = C.[Column_Name]
			Or
			A.[Table_Catalog] = C.[Table_Catalog] And A.[Table_Schema] = C.[Table_Schema] And C.[Table_Name] = @All_Combinations_Tag And C.[Column_Name] = @All_Combinations_Tag
			Or
			C.[Table_Catalog] = @All_Combinations_Tag And A.[Table_Schema] = C.[Table_Schema] And A.[Table_Name] = C.[Table_Name] And C.[Column_Name] = @All_Combinations_Tag
			Or
			C.[Table_Catalog] = @All_Combinations_Tag And A.[Table_Schema] = C.[Table_Schema] And C.[Table_Name] = @All_Combinations_Tag And A.[Column_Name] = C.[Column_Name]
			Or
			A.[Table_Catalog] = C.[Table_Catalog] And C.[Table_Schema] = @All_Combinations_Tag And A.[Table_Name] = C.[Table_Name] And C.[Column_Name] = @All_Combinations_Tag
			--Three Protocol Values Wildcarded
			Or
			C.[Table_Catalog] = @All_Combinations_Tag And C.[Table_Schema] = @All_Combinations_Tag And C.[Table_Name] = @All_Combinations_Tag And A.[Column_Name] = C.[Column_Name]
			Or
			A.[Table_Catalog] = C.[Table_Catalog] And C.[Table_Schema] = @All_Combinations_Tag And C.[Table_Name] = @All_Combinations_Tag And C.[Column_Name] = @All_Combinations_Tag
			Or
			C.[Table_Catalog] = @All_Combinations_Tag And C.[Table_Schema] = @All_Combinations_Tag And A.[Table_Name] = C.[Table_Name] And C.[Column_Name] = @All_Combinations_Tag
			Or
			C.[Table_Catalog] = @All_Combinations_Tag And A.[Table_Schema] = C.[Table_Schema] And C.[Table_Name] = @All_Combinations_Tag And C.[Column_Name] = @All_Combinations_Tag
			)
		Cross Join @Search_Protocols D
		Where
			B.[Data_Type_Name] Is Null
			And C.[Table_Catalog] Is Null
			--We only need to efficiently check the one column for nullity, because we handle the join cleverly above!!!
		Group By A.[Table_Catalog], A.[Table_Schema], A.[Table_Name], A.[Column_Name], D.[Search_String], D.[Match_Type]

		End

	Else

		Begin

			If (select 1 where Exists (select 1 from @Whitelist_Inlcusions)) Is Null
				If (select 1 where Exists (select 1 from @Blacklist_Ignores)) Is Null

					Begin

					Insert Into @Triangulation_Dynamic_Search ([Substatementlet_Strings])
					Select
						((N'Select Max(''' + Cast(A.[Table_Catalog] As NVarchar(Max)) + N''') As [Table_Catalog], Max(''' + Cast(A.[Table_Schema] As NVarchar(Max)) + N''') As [Table_Schema], Max(''' + Cast(A.[Table_Name] As NVarchar(Max)) + N''') As [Table_Name], Max(''' + Cast(A.[Column_Name] As NVarchar(Max)) + N''') As [Column_Name], Max(''' + Cast(D.[Search_String] As NVarchar(Max)) + N''') As [Search_String], Max(''' + Cast(D.[Match_Type] As NVarchar(Max)) + N''') As [Match_Type] From [' + (Cast(A.[Table_Catalog] As NVarchar(Max)) + N'].[' + Cast(A.[Table_Schema] As NVarchar(Max)) + N'].[' + Cast(A.[Table_Name] As NVarchar(Max)))) + (N'] Where [' + Cast(A.[Column_Name] As NVarchar(Max)) + (Case When D.[Match_Type] = 'Exact' Then (N'] Like ''' + Cast(D.[Search_String] As NVarchar(4000)) + N'''') Else (Case When D.[Match_Type] = 'Partial' Then (N'] Like ''%' + Cast(D.[Search_String] As NVarchar(4000)) + N'%''') Else 'Pray_Beg_Forgiveness_For_This_Error' End) End)) + ' Group By [' + Cast(A.[Column_Name] As NVarchar(Max)) + ']') As [Dynamic_Join_String]
					From Information_Schema.Columns A
					Left Join @Ignore_Column_Data_Types B On 
						(A.[Data_Type] = B.[Data_Type_Name])
					Cross Join @Search_Protocols D
					Where
						B.[Data_Type_Name] Is Null
					Group By A.[Table_Catalog], A.[Table_Schema], A.[Table_Name], A.[Column_Name], D.[Search_String], D.[Match_Type]

					End
		
		End

	End
--SOURCECODE_LOGICAL_CHUNK--SOURCECODE_LOGICAL_CHUNK--SOURCECODE_LOGICAL_CHUNK--SOURCECODE_LOGICAL_CHUNK--SOURCECODE_LOGICAL_CHUNK
Select * From @Triangulation_Dynamic_Search
Declare @SQL_Command As NVarchar(Max)
Set @SQL_Command = (Select String_Agg([Substatementlet_Strings], N' Union All ') From @Triangulation_Dynamic_Search)
Select @SQL_Command
Declare @Triangulations Table ([Table_Catalog] NVarchar(Max), [Table_Schema] NVarchar(Max), [Table_Name] NVarchar(Max), [Column_Name] NVarchar(Max), [Search_String] NVarchar(4000), [Match_Type] NVarchar(4000))
Insert Into @Triangulations
Execute sp_executesql @SQL_Command


--OUTPUT CHECK
--Here is the search protocols' final results... The select statement is capable of showing all triangulations of database objects which contain the search strings of interest in at least one of their associated data values...
--If you need less or more detailed information, simply adjust the commenting in the select statemnt below (you will need to make sure that the select columns and the group by columns are hamronised i_e_ they match up, because if there is a select column without its requisite grouping column, then the command will fail).
Select
	[Table_Catalog],
	[Table_Schema],
	[Table_Name],
	[Column_Name],
	[Search_String],
	[Match_Type]
From @Triangulations Group By [Table_Catalog], [Table_Schema], [Table_Name], [Column_Name], [Search_String], [Match_Type]