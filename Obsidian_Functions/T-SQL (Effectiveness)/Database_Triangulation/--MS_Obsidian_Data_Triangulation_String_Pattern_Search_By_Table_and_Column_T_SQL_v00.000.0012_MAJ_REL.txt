--MS_Obsidian_Database_Triangulation_String_Pattern_Search_By_Table_and_Column_T_SQL_v00.000.0012_MAJ_REL
--This algorithm can be packaged into a stored procedure if desired... Otherwise, simply cut and paste, and adjust the global variables before each execution...
--It allows you to pass in a string pattern, which will then be searched for across all the tables in your database...
--If you want to also use this search against views, then please feel free to make the appropriate amendments...
--The output provides a list of all the table names and column names that contain the search string pattern within their requisite cell data...
--There are global variables available regarding switching between exact match and partial match, but please be aware that exact match is likely to be a much quicker search in almost all circumstances...


--GLOBAL VARIABLES
Declare @Search_String As NVarchar(4000)
Set @Search_String = '149ED75C889A4356ADF8D6E95A729ACD'

--This variable can be set to either: "Exact" or "Partial" (In either case, without the double quotes)
Declare @Match_Type As NVarchar(Max)
Set @Match_Type = N'Exact'

--Use this table variable to set the column data types for the algorithm to ignore... Afterall, one should probably not attempt to search a textual string against data values in and image column (this is not IDs or computer/human language) or even varbinary column (this is almost always not a useful task)... You can add any user-defined data types here also.
Declare @Ignore_Column_Data_Types Table ([Data_Type_Name] NVarchar(4000))
Insert Into @Ignore_Column_Data_Types ([Data_Type_Name])
Values
('geography'),
('geometry'),
('hierarchyid'),
('image'),
('rowversion'),
('varbinary'),
('xml'),
('bit'),
('User_Defined_Type_Example_0001') --An example user-defined data type, i think.

--Use this table variable to set the table names for the algorithm to ignore... Afterall, one should probably not attempt to search through absolutely massive tables in a lax way, or without great cause... You can even choose to manually ignore tables that you think are causing the algorithm to crash, for example because of strange data types or something.
Declare @Ignore_Tables Table ([Table_Name] NVarchar(4000))
Insert Into @Ignore_Tables ([Table_Name])
Values
('Table_Name_Example_0001'),
('Table_Name_Example_0002')


--ALGORITHM EXECUTION
Declare @Delimited_Search_String As NVarchar(4000)
If @Match_Type = N'Exact'
	Set @Delimited_Search_String = (N'] As NVarchar(Max)) Like ''' + @Search_String + N''' Or Cast([')
If @Match_Type = N'Partial'
	Set @Delimited_Search_String = (N'] As NVarchar(Max)) Like ''%' + @Search_String + N'%'' Or Cast([')

Declare @Terminating_Search_String As NVarchar(4000)
If @Match_Type = N'Exact'
	Set @Terminating_Search_String = (N'] As NVarchar(Max)) Like ''' + @Search_String + N'''')
If @Match_Type = N'Partial'
	Set @Terminating_Search_String = (N'] As NVarchar(Max)) Like ''%' + @Search_String + N'%''')

Declare @System_Table_Prepared_For_Dynamic_Search Table ([Dynamic_Join_String] NVarchar(Max))
Insert Into @System_Table_Prepared_For_Dynamic_Search ([Dynamic_Join_String])
Select
	((N'Select Max(''' + Cast(A.[Table_Name] As NVarchar(Max)) + N''') As [Table_Name], Max(''' + Cast(A.[Column_Name] As NVarchar(Max)) + N''') As [Column_Name] From ' + Cast(A.[Table_Name] As NVarchar(Max))) + (N' Where Cast([' + Cast(A.[Column_Name] As NVarchar(Max)) + @Terminating_Search_String) + ' Group By [' + Cast(A.[Column_Name] As NVarchar(Max)) + ']') As [Dynamic_Join_String]
From Information_Schema.Columns A
Left Join @Ignore_Column_Data_Types B On 
	(A.[Data_Type] = B.[Data_Type_Name])
Left Join @Ignore_Tables C On
	(A.[Table_Name] = C.[Table_Name])
Where
	B.[Data_Type_Name] Is Null
	And C.[Table_Name] Is Null
Group By A.[Table_Name], A.[Column_Name]

Declare @SQL_Command As NVarchar(Max)
Set @SQL_Command = Cast((Select String_Agg(Cast([Dynamic_Join_String] As NVarchar(Max)), N' Union All ') From @System_Table_Prepared_For_Dynamic_Search) As NVarchar(Max))
Select @SQL_Command
Declare @Table_matches Table ([Table_Name] NVarchar(Max), [Column_Name] NVarchar(Max))
Insert Into @Table_Matches
Execute sp_executesql @SQL_Command


--OUTPUT CHECK
--Here are the tables which contain the search string in at least one of their data values...
Select [Table_Name] From @Table_matches Group By [Table_Name]
--If you need more detailed column level information, here is an additonal column which indicates the columns in each table, which contain the search string in at least one of their data values...
Select * From @Table_matches