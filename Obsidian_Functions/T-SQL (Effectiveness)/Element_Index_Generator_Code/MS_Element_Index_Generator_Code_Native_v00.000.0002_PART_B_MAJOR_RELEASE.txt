--The following codeblocks produce dynamically structured code in order to generate a single column table of increasing integer index values.
Declare @Index_Count BigInt
Set @Index_Count = 100

Declare @Dynamic_SQL_1 Nvarchar(Max)
Set @Dynamic_SQL_1 = N'(Select dbo.Obsidian_Element_Index_Generator_Code_Native(@Parameter_1))'

Declare @Dynamic_SQL_Parameter_Definition_1 Nvarchar(Max)
Set @Dynamic_SQL_Parameter_Definition_1 = N'@Parameter_1 BigInt'

Declare @Dynamic_SQL_Intermediate_Table_Variable_1 Table ([Intermediate_SQL] Nvarchar(Max))
Insert Into @Dynamic_SQL_Intermediate_Table_Variable_1 ([Intermediate_SQL])
Execute sp_executesql @Dynamic_SQL_1, @Dynamic_SQL_Parameter_Definition_1, @Parameter_1 = @Index_Count

Declare @Dynamic_SQL_Data_Intermediate_Variable Nvarchar(Max)
Set @Dynamic_SQL_Data_Intermediate_Variable = (Select Replace([Intermediate_SQL], '@Index_Count', @Index_Count) From @Dynamic_SQL_Intermediate_Table_Variable_1)

Declare @Obsidian_Data_Element_Index Table ([Element_Index] BigInt)
Insert Into @Obsidian_Data_Element_Index ([Element_Index]) --You could just use an existing table of integers here, which would greatly speed up the query for big data applications where for example billions, trillions, or quadrillions of integers are needed on a daily basis.
Execute (@Dynamic_SQL_Data_Intermediate_Variable)

Select * From @Obsidian_Data_Element_Index