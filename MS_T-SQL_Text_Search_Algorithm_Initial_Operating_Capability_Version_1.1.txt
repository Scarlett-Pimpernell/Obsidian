--HEADER:
--MS_T-SQL_Text_Search_Algorithm
--Initial Operating Capability - Version 1.1


--OVERVIEW:
--The current algorithm takes a search text variable,
--splits the search text variable into a table variable using space delimiters,
--cross references the table variable to multiple element type tables using a join construct,
--assigns a whole match score column value based on the repository elements' name's whole match likeness,
--assigns a slide match score column value based on the repository elements' name's extended slide match likeness (for typo handling),
--assigns an split match score column value based on the repository elements' name's split match likeness,
--assigns a length score column value based on the repository elements' name's length unlikeness,
--assigns an aggregate score column value based on all of the basic score column values,
--filters the aggregate score column by a score threshold variable,
--and finally orders by optimal cascading of the values in the basic score columns.

--USAGE DIRECTIONS:
--This algorithm should be used in Microsoft SQL Server 2017.
--Don't forget to include the desired search text variable delimiters, and element tables,
--with their corresponding name columns, into the appropriate query blocks below.
--Turning on the full text indexing feature may significantly speed up query execution time.

--FUNCTIONALITY STILL TO BE INCLUDED IN THE ALGORITHM INCLUDES:
--Integrate A Standard Synonym database --> Estimated Release: Nov 2019.
--Integrate A Client Enterprise Specific Synonym database --> Estimated Release: Dec 2019.
--Integrate A Client Enterprise Specific Word Stemming Technique --> Estimated Release: Jan 2020.
--Dimensional Boosting By Viewed Element Network/Peers/Ancestors/Descendants --> Estimated Release: Feb 2020.
--Dimensional Boosting By Epoch Network/Peers/Ancestors/Descendants --> Estimated Release: Mar 2020.
--Dimensional Boosting By User Segment Relationships --> Estimated Release: Apr 2020.

--TESTING CHECKS:
--Check Query For Efficiency Upgrade Options.
--Check Query For Protection Against SQL Injection Attacks.
--Check Production Environment Algorithm Performance, On Big-Data Scale (Millions Of Search Elements) Or Hyper-Data Scale (Billions Of Search Elements).

--NOTA BENE:
--If this query runs slowly, consider using an effectively sub-optimal, yet more efficient, compound ordering column.
--This search algorithm excludes search operator functionality, but including search operators would be a relatively simple change if a specific client asked for this requirement.


Declare @Search_Text As Nvarchar(100)
Set @Search_Text = 'Michael Loves Using MooD 190101' --This variable should ideally be constrained to <= 50 characters long.


Declare @Element_Names_Table_Variable TABLE([Name] Nvarchar(100) NOT NULL)
Insert Into @Element_Names_Table_Variable
SELECT [Name]
From dbo.Elements_Type_01
Union
SELECT [Name]
From dbo.Elements_Type_02
--Add desired element tables here, along with their name columns and a placeholder aggregate score column.


Declare @Search_Text_Typo_Granularity_Percentage As Int
Set @Search_Text_Typo_Granularity_Percentage = 20 --This variable value must be constrained to 0>=x<=100... In order to experience good effectiveness, values between 10% and 50% are recommended.

Declare @Search_Text_Extended_Slide_Table_Variable TABLE([Slide_Value] Nvarchar(100) NOT NULL)
Insert Into @Search_Text_Extended_Slide_Table_Variable
Select Substring(A.B, V.[Number]+1, Case When (Len(@Search_Text) * @Search_Text_Typo_Granularity_Percentage / 100) > 1 Then Len(@Search_Text) * @Search_Text_Typo_Granularity_Percentage / 100 Else 1 End) As [Slide_Value]
From (Select @Search_Text B) A
join Master..Spt_Values V On V.[Number] < Len(A.B)
where V.Type = 'P' --This query slides across a string variable by one position at a time. As a result, the leading characters carry less weight than the rest of the characters... This is fixed by joining the results of a partial reverse search text slide, as seen below.
Union
Select Reverse(Substring(A.B, V.[Number]+1, Case When (Len(@Search_Text) * @Search_Text_Typo_Granularity_Percentage / 100) > 1 Then Len(@Search_Text) * @Search_Text_Typo_Granularity_Percentage / 100 Else 1 End)) As [Slide_Value]
From (Select Reverse(@Search_Text) B) A
join Master..Spt_Values V On V.[Number] < Len(A.B)
where V.Type = 'P'
And V.[Number] > Len(@Search_Text) - (Len(@Search_Text) * @Search_Text_Typo_Granularity_Percentage / 100)


Declare @Search_Text_Split_Table_Variable TABLE([Value] Nvarchar(100) NOT NULL)
Insert Into @Search_Text_Split_Table_Variable
SELECT [Value] From String_Split(@Search_Text, ' ') --Add desired delimiters here.


Declare @Length_Score_Table_Variable TABLE([Raw_Length_Deviation_Score] FLoat)
Insert Into @Length_Score_Table_Variable
Select
	SQRT(SQUARE((Cast(LEN([Name]) - LEN(@Search_Text) As Float) / Cast(LEN(@Search_Text) As Float)) * 100)) As [Raw_Length_Deviation_Score]
		From @Element_Names_Table_Variable
			Order By [Raw_Length_Deviation_Score] Desc

Declare @Top_Length_Deviation_Score As Float
Set @Top_Length_Deviation_Score = (Select Top (1) [Raw_Length_Deviation_Score] From @Length_Score_Table_Variable)


Declare @Search_Results_A TABLE([Name] Nvarchar(100) Not Null, [Whole_Match_Score] FLoat, [Split_Match_Score] FLoat, [Length_Deviation_Score] FLoat)
Insert Into @Search_Results_A
Select
	[Name],
	Cast(Case When [Name] Like '%'+@Search_Text+'%' Then Round(100.00 / 4, 3) Else 0 End As Float) As [Whole_Match_Score],
	Cast(Case When [Name] Like '%'+[Value]+'%' Then Round(100.00 / 4, 3) Else 0 End As Float) As [Split_Match_Score],
	Round(((SQRT(SQUARE((Cast(LEN([Name]) - LEN(@Search_Text) As Float) / Cast(LEN(@Search_Text) As Float)) * 100)) / @Top_Length_Deviation_Score) * 100) / 4, 3) As [Length_Deviation_Score]
		From @Element_Names_Table_Variable
			Cross Join @Search_Text_Split_Table_Variable
				Where [Value] <> ''

Declare @Search_Results_B TABLE([Name] Nvarchar(100) NOT NULL, [Slide_Match_Score] FLoat)
Insert Into @Search_Results_B
Select
	[Name],
	Cast(Case When [Name] Like '%'+[Slide_Value]+'%' Then Round(100.00 / 4, 3) Else 0 End As Float) As [Slide_Match_Score]
		From @Element_Names_Table_Variable
			Cross Join @Search_Text_Extended_Slide_Table_Variable
				Where [Slide_Value] <> ''						


Declare @Aggregate_Score_Threshold As Int
Set @Aggregate_Score_Threshold = 5 --This variable value must be constrained to 0>=x<=100.


Select
A.[Name] As [Name],
Cast(Avg(A.[Whole_Match_Score]) As Decimal(5, 2)) As [Whole_Match_Score],
Cast(Avg(B.[Slide_Match_Score]) As Decimal(5, 2)) As [Slide_Match_Score],
Cast(Avg(A.[Split_Match_Score]) As Decimal(5, 2)) As [Split_Match_Score],
Cast(Avg(A.[Length_Deviation_Score]) As Decimal(5, 2)) As [Length_Deviation_Score],
Cast(Avg(A.[Whole_Match_Score] + B.[Slide_Match_Score] + A.[Split_Match_Score] - ((A.[Length_Deviation_Score]) / 100) * (A.[Whole_Match_Score] + B.[Slide_Match_Score] + A.[Split_Match_Score])) As Decimal(5, 2)) As [Aggregate_Score]
From @Search_Results_A A Inner Join @Search_Results_B B
	On (A.[Name] = B.[Name])
		Group By A.[Name]
			Having Cast(Avg(A.[Whole_Match_Score] + B.[Slide_Match_Score] + A.[Split_Match_Score] - ((A.[Length_Deviation_Score] / 100) * (A.[Whole_Match_Score] + B.[Slide_Match_Score] + A.[Split_Match_Score]))) As Decimal(5, 2)) > = @Aggregate_Score_Threshold
				Order By [Whole_Match_Score] Desc, [Slide_Match_Score] Desc, [Split_Match_Score] Desc, [Length_Deviation_Score] Asc, [Aggregate_Score] Desc