--HEADER:
--MS Text Search Algorithm
--T-SQL
--SQL Server 2019
--Initial Operating Capability
--Version 1.1


--OVERVIEW:
--The current algorithm takes a search text variable,
--splits the search text variable into a table variable using space delimiters,
--cross references the table variable to multiple element type tables using a join construct,
--assigns a whole match score column value based on the repository elements' name's whole match likeness,
--assigns a slide match score column value based on the repository elements' name's extended slide match likeness (for typo handling),
--assigns a split match score column value based on the repository elements' name's split match likeness,
--assigns a generic synonym split match score column value based on the repository elements' name's generic synonym split match likeness,
--assigns a length score column value based on the repository elements' name's length unlikeness,
--assigns an aggregate score column value based on all of the basic score column values,
--filters the aggregate score column by a score threshold variable,
--and finally orders by optimal cascading of the values in the basic score columns.

--USAGE DIRECTIONS:
--This algorithm should be used in Microsoft SQL Server 2019.
--Don't forget to include the desired search text variable delimiters, and element tables,
--with their corresponding name columns, into the appropriate query blocks below.
--Turning on the full text indexing feature may significantly speed up query execution time.

--FUNCTIONALITY STILL TO BE INCLUDED IN THE ALGORITHM INCLUDES:
--Integrate A Generic Synonym Matching Technique --> Estimated Release: Apr 2020.
--Integrate A Data Science Synonym Matching Technique --> Estimated Release: Apr 2020.
--Integrate A Client Enterprise Specific Synonym Matching Technique --> Estimated Release: May 2020.
--Integrate A Client Enterprise Specific Phrase Inferencing Technique --> Estimated Release: June 2020.
--Integrate Dimensional Boosting By Viewed Element Network/Peers/Ancestors/Descendants --> Estimated Release: Jul 2020.
--Integrate Dimensional Boosting By Epoch Network/Peers/Ancestors/Descendants --> Estimated Release: Aug 2020.
--Integrate Dimensional Boosting By User Segment Groups --> Estimated Release: Sep 2020.

--TESTING:
--Optimise Query For Compute Efficiency.
--Optimise indexes on referenced tables.
--Check Query For Protection Against SQL Injection Attacks.
--Check Production Environment Algorithm Performance, On Big-Data Scale (Millions Of Search Elements) Or Hyper-Data Scale (Billions Of Search Elements).

--NOTA BENE:
--The ideal production use case for this algorithm includes the caching of a core set of common search text variables.
--If this query runs too slowly on your available hardware, consider using only the aggregate score column for ordering. This would be effectively sub-optimal, yet more efficient.
--This search algorithm excludes search operator functionality, but including search operators would be a relatively simple change if a specific client asked for this requirement.


Declare @Search_Text As Nvarchar(100)
Set @Search_Text = 'Michael Loves Using MooD 101' --This variable should ideally be constrained to <= 50 characters long.


Declare @Element_Names_Table_Variable TABLE([Name] Nvarchar(100) NOT NULL)
Insert Into @Element_Names_Table_Variable
SELECT [Name] As [Name]
From dbo.Elements_Type_01
Union
SELECT [Name] As [Name]
From dbo.Elements_Type_02
--Add desired element tables here, along with their name columns.


Declare @Obsidian_Generic_Thesaurus_Table_Variable TABLE([Word] Nvarchar(400), [Synonym] Nvarchar(400))
Insert Into @Obsidian_Generic_Thesaurus_Table_Variable
SELECT [Word] As [Word], [Synonym] As [Synonym]
From dbo.Obsidian_Generic_Thesaurus
--The Obsidian_Generic_Thesaurus table must be loaded into memory in order to use it later on in join statments which produce the search algorithm results with other in-memory tables.


Declare @Search_Text_Typo_Granularity_Percentage As Int
Set @Search_Text_Typo_Granularity_Percentage = 15 --This variable value must be constrained to 0>=x<=100... In order to experience good effectiveness, values between 10% and 50% are recommended.

Declare @Search_Text_Extended_Slide_Table_Variable TABLE([Slide_Value] Nvarchar(100) NOT NULL)
Insert Into @Search_Text_Extended_Slide_Table_Variable
Select Substring(A.B, V.[Number]+1, Case When (Len(@Search_Text) * @Search_Text_Typo_Granularity_Percentage / 100) > 1 Then Len(@Search_Text) * @Search_Text_Typo_Granularity_Percentage / 100 Else 1 End) As [Slide_Value]
From (Select @Search_Text B) A
join Master..Spt_Values V On V.[Number] < Len(A.B)
where V.Type = 'P' --This query slides across a string variable by one position at a time. As a result, the leading characters carry less weight than the rest of the characters... This is fixed by joining the results of a partial reverse search text slide, as seen below.
Union
Select Reverse(Substring(A.B, V.[Number]+1, Case When (Len(@Search_Text) * @Search_Text_Typo_Granularity_Percentage / 100) > 1 Then Len(@Search_Text) * @Search_Text_Typo_Granularity_Percentage / 100 Else 1 End)) As [Slide_Value]
From (Select Reverse(@Search_Text) B) A
join Master..Spt_Values V On V.[Number] < Len(A.B)
where V.Type = 'P'
And V.[Number] > Len(@Search_Text) - (Len(@Search_Text) * @Search_Text_Typo_Granularity_Percentage / 100)


Declare @Search_Text_Split_Table_Variable TABLE([Value] Nvarchar(100) NOT NULL)
Insert Into @Search_Text_Split_Table_Variable
SELECT [Value] From String_Split(@Search_Text, ' ') --Add desired delimiter here.


Declare @Synonym_Lookup_Table_Variable TABLE([Synonym] Nvarchar(100))
Insert Into @Synonym_Lookup_Table_Variable
Select
	B.[Synonym]
		From @Search_Text_Split_Table_Variable A
			Inner Join @Obsidian_Generic_Thesaurus_Table_Variable B
			On (A.[Value] = B.[Word])
				Where A.[Value] <> '' And B.[Synonym] <> ''


Declare @Length_Score_Table_Variable TABLE([Raw_Length_Deviation_Score] FLoat)
Insert Into @Length_Score_Table_Variable
Select
	SQRT(SQUARE((Cast(LEN([Name]) - LEN(@Search_Text) As Float) / Cast(LEN(@Search_Text) As Float)) * 100)) As [Raw_Length_Deviation_Score]
		From @Element_Names_Table_Variable

Declare @Top_Length_Deviation_Score As Float
Set @Top_Length_Deviation_Score = (Select Top (1) [Raw_Length_Deviation_Score] From @Length_Score_Table_Variable Order By [Raw_Length_Deviation_Score] Desc)


Declare @Search_Results_A TABLE([Name] Nvarchar(100) Not Null, [Whole_Match_Score] FLoat, [Length_Deviation_Score] FLoat)
Insert Into @Search_Results_A
Select
	[Name],
	Cast(Case When [Name] Like '%'+@Search_Text+'%' Then 100.000 / 4 Else 0 End As Float) As [Whole_Match_Score],
	(SQRT(SQUARE((Cast(LEN([Name]) - LEN(@Search_Text) As Float) / Cast(LEN(@Search_Text) As Float)) * 100)) / @Top_Length_Deviation_Score) * 100 As [Length_Deviation_Score]
		From @Element_Names_Table_Variable

Declare @Search_Results_B TABLE([Name] Nvarchar(100) NOT NULL, [Slide_Match_Score] FLoat)
Insert Into @Search_Results_B
Select
	[Name],
	Cast(Case When [Name] Like '%'+[Slide_Value]+'%' Then 100.000 / 4 Else 0 End As Float) As [Slide_Match_Score]
		From @Element_Names_Table_Variable
			Cross Join @Search_Text_Extended_Slide_Table_Variable
				Where [Slide_Value] <> ''
				
Declare @Search_Results_C TABLE([Name] Nvarchar(100) Not Null, [Split_Match_Score] FLoat)
Insert Into @Search_Results_C
Select
	[Name],
	Cast(Case When [Name] Like '%'+[Value]+'%' Then 100.000 / 4 Else 0 End As Float) As [Split_Match_Score]
		From @Element_Names_Table_Variable
			Cross Join @Search_Text_Split_Table_Variable
				Where [Value] <> ''

Declare @Search_Results_D TABLE([Name] Nvarchar(100) Not Null, [Generic_Synonym_Match_Score] FLoat)
Insert Into @Search_Results_D
Select
	[Name],
	Cast(Case When [Name] Like '%'+[Synonym]+'%' Then 100.000 / 4 Else 0 End As Float) As [Generic_Synonym_Match_Score]
		From @Element_Names_Table_Variable
			Cross Join @Synonym_Lookup_Table_Variable


Declare @Aggregate_Score_Threshold As Int
Set @Aggregate_Score_Threshold = 0 --This variable value must be constrained to 0>=x<=100.

Select
A.[Name] As [Name],
Cast(Avg(A.[Whole_Match_Score]) As Decimal(5, 2)) As [Whole_Match_Score],
Cast(Avg(B.[Slide_Match_Score]) As Decimal(5, 2)) As [Slide_Match_Score],
Cast(Avg(C.[Split_Match_Score]) As Decimal(5, 2)) As [Split_Match_Score],
Cast(Avg(D.[Generic_Synonym_Match_Score]) As Decimal(5, 2)) As [Generic_Synonym_Match_Score],
Cast(Avg(A.[Length_Deviation_Score]) As Decimal(5, 2)) As [Length_Deviation_Score],
Cast(Avg(A.[Whole_Match_Score] + B.[Slide_Match_Score] + C.[Split_Match_Score] + D.[Generic_Synonym_Match_Score] - ((A.[Length_Deviation_Score] / 100) * (A.[Whole_Match_Score] + B.[Slide_Match_Score] + C.[Split_Match_Score] + D.[Generic_Synonym_Match_Score]))) As Decimal(5, 2)) As [Aggregate_Score]
From @Search_Results_A A 
	Inner Join @Search_Results_B B
	On (A.[Name] = B.[Name])
	Inner Join @Search_Results_C C
	On (A.[Name] = C.[Name])
	Inner Join @Search_Results_D D
	On (A.[Name] = D.[Name])
		Group By A.[Name]
			Having Cast(Avg(A.[Whole_Match_Score] + B.[Slide_Match_Score] + C.[Split_Match_Score] + D.[Generic_Synonym_Match_Score] - ((A.[Length_Deviation_Score] / 100) * (A.[Whole_Match_Score] + B.[Slide_Match_Score] + C.[Split_Match_Score] + D.[Generic_Synonym_Match_Score]))) As Decimal(5, 2)) > = @Aggregate_Score_Threshold
				Order By [Whole_Match_Score] Desc, [Slide_Match_Score] Desc, [Split_Match_Score] Desc, [Generic_Synonym_Match_Score] Desc, [Length_Deviation_Score] Asc, [Aggregate_Score] Desc

--The last 7 query blocks can be consolidated into just 2 or 3 query blocks in a production deployment where achieving the highest efficiency performance is essential. In this query however, I have kept them separate for the purpose of ease of understanding. 